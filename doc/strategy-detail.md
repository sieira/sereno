## The keys
Using a REST architecture will mean that the application server will not keep track of the users interaction, so there's two options left:
 1. The key is the same for all the encrypted data, and it's generated by the server.
  * This option is discarded, it would result in the encrypted information lost anytime the server stops (because it will loose the key), or in the key being known by the server manager, or in this same key being stored in the database along with the data it encrypted.
 2. The key has to be different for each user and thus, be deductible from the users given information, leading to two possibilities:
  1. The user knows and transmits both his password and this key. In that case, the user has to be requested the key each time he wants to access the data.
  2. The server stores this key, leading to the same problem mentioned in point one, that the key will be (at least *during the user's session*), stored in the same database than the information it encrypts.

  Whereas in the first case the key first key has to be persistent (it's used to encrypt and decrypt the data), the second one

 (the )

 And the key used for it has to be different for each user.

# Considerations
  1. The database will keep all the user mailbox passwords.
  2. This information has to be secured.
  3. This information has to be retrievable by the server.
  4. The database shall not contain the key used to encrypt the passwords.
  5. The app server should be able to calculate this key by itself only by using
     the information given by the client.
  6. This calculation should not expose the user password, nor the e-mail keys

# Strategy
 * u = user
 * mb = mailbox
 * t = token
 * uk = user key
 * mk = mail client key
 * uh()  = hash algorithm for user keys
 * mh()  = hash algorithm for mail keys
 * sc(mk, mh(uk)) = symmetric algorithm

## Step 1
//TODO
1. The server generates a session key, this key will be used to encrypt the
   generated key which will be used to encrypt passwords
2. This key has to be renewed every now and then, and the database has to update

## Step 2
When the user logs in
1. The client requests to login sending his key through SSL
2. The application server calculates the hash of the key and checks with the database
3. If the login succeeds, it calculates a second hash (different algorithm) and keeps it private
4. The server generates a token and sends it to the client

```
       Client
 ._________________.
 | _______________ |
 | |   read uk   | |
 | |   delete uk | |
 | |_____________| |
 !_________________!
._____[_______]_____.
|::::::::::::::: :::|
!___________________!
  SSL(uk)      ^
    |          |
    |          |
    v        token
+------------------------------+            +------------------------+
|          NodeServer          |            |         Mongo          |
+------------------------------+  req(u)    +------------------------+
| LoginWith(uh(uk))            |----------->|                        |
| if(OK) generate token        | (u,uh(uk)) | Send user data to node |
|  Calculate and store mh(uk)  |<-----------|                        |
| Delete uk and uh(uk)         |   mh(uk)   |                        |
|                              |----------->|                        |
+------------------------------+            +------------------------+
```

## Step 3
When the user requests it's e-mails :
 1. The client sends a request to the node-server
 2. The node server checks that the user is properly identified
 3. The node server requests the password list (encrypted)
 4. The node server uses the stored mh(uk) to decrypt the passwords
 5. The node server operates with the imap server and sends the results to the client

```
        Client
  ._________________.
  | _______________ |
  | |   read uk   | |
  | |   delete uk | |
  | |_____________| |
  !_________________!
 ._____[_______]_____.
 |::::::::::::::: :::|
 !___________________!
 req(mb,u,t)     ^
      |          |
      |          |
      v        inbox
+------------------------------+                      +------------------------+
|          NodeServer          |                      |         Mongo          |
+------------------------------+ (mb,sc(mk,mh(uk)))   +------------------------+
|  Authenticate user           |<---------------------|                        |
|  get mailbox password        |                      |                        |
|  use mh(uk) to get the plain |                      +------------------------+
|    password                  |
+------------------------------+
SSL(mb,mk)     ^
     |         |
     |         |
     v       inbox
   _______________
  |\             /|
  | \           / |
  | /\_________/\ |
  |/             \|
  |_______________|

```

# Conclusion
The given strategy guarantees that:
 * The database do not store the user password (just a hash)
 * The database do not store the mail passwords (cyphered version)
 * The database do not know, nor is able to compute the mail passwords key
 * The client only knows the user password
 * The web server keeps at a given point in memory the user password, it's hash
   and the hash used as key for the mail password, but never transmits them.
